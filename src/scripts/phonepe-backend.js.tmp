const express = require('express');
const cors = require('cors');
const crypto = require('crypto');
const admin = require('firebase-admin');
const axios = require('axios');
require('dotenv').config();

// === SECURE FIREBASE INITIALIZATION ===
let serviceAccount;
try {
  if (process.env.FIREBASE_SERVICE_ACCOUNT) {
    console.log('Loading Firebase credentials from Environment Variable...');
    serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
  } else {
    console.log('Loading Firebase credentials from local file...');
    serviceAccount = require('../../service-account-key.json');
  }
  if (!admin.apps.length) {
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
    });
  }
} catch (error) {
  console.error('CRITICAL: Firebase Auth Failed. Check your keys.');
  process.exit(1);
}

const db = admin.firestore();
const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: false })); 

// === CONFIGURATION (Sandbox) ===
const MERCHANT_ID = 'PGTESTPAYUAT86';
const PHONEPE_SALT = '96434309-7796-489d-8924-ab56988a6076';
const PHONEPE_SALT_INDEX = '1';
const PHONEPE_API_URL = 'https://api-preprod.phonepe.com/apis/pg-sandbox/pg/v1/pay';
// Ensure this matches your current Ngrok URL
const PHONEPE_BACKEND_URL = process.env.PHONEPE_BACKEND_URL || 'https://percutaneous-bairnish-winfred.ngrok-free.dev'; 

// --- Helper: Generate Checksum ---
const generateChecksum = (base64Body, salt, saltIndex, apiPath) => {
  const stringToHash = base64Body + apiPath + salt;
  const sha256 = crypto.createHash('sha256').update(stringToHash).digest('hex');
  return `${sha256}###${saltIndex}`;
};

// --- Helper: Clean PhonePe Response ---
const cleanPhonePeResponse = (data) => {
  // Create a copy to avoid mutating original
  const cleaned = { ...data };
  // Remove the 20 empty param fields to save DB space
  for (let i = 1; i <= 20; i++) {
    delete cleaned[`param${i}`];
  }
  return cleaned;
};

// --- Endpoint: Payment Request ---
app.post('/generate-payment-request', async (req, res) => {
  try {
    const { amount, orderId, customerId, redirectUrl, callbackUrl } = req.body;
    const payload = {
      merchantId: MERCHANT_ID,
      merchantTransactionId: orderId,
      merchantUserId: customerId,
      amount: amount * 100, 
      redirectUrl: redirectUrl || `${PHONEPE_BACKEND_URL}/payment/callback`,
      redirectMode: 'POST',
      callbackUrl: callbackUrl || `${PHONEPE_BACKEND_URL}/payment/callback`,
      mobileNumber: '9999999999',
      paymentInstrument: { type: 'PAY_PAGE' }
    };

    const base64Payload = Buffer.from(JSON.stringify(payload), 'utf8').toString('base64');
    const checksum = generateChecksum(base64Payload, PHONEPE_SALT, PHONEPE_SALT_INDEX, '/pg/v1/pay');

    const response = await axios.post(
      PHONEPE_API_URL,
      { request: base64Payload },
      { headers: { 'Content-Type': 'application/json', 'X-VERIFY': checksum, 'X-MERCHANT-ID': MERCHANT_ID } }
    );

    if (response.data.success) {
      res.json({
        success: true,
        data: {
          requestId: orderId,
          merchantId: MERCHANT_ID,
          payload: base64Payload,
          checksum: checksum,
          paymentUrl: response.data.data.instrumentResponse.redirectInfo.url 
        }
      });
    } else {
      throw new Error('PhonePe responded with success:false');
    }
  } catch (error) {
    console.error('Error generating request:', error.message);
    res.json({ 
      success: true, 
      data: { 
        // Fallback for testing if API fails
        paymentUrl: `https://mercury-uat.phonepe.com/transact/simulator?token=FAIL_FALLBACK` 
      } 
    });
  }
});

// --- Endpoint: Callback ---
app.post('/payment/callback', async (req, res) => {
  try {
    let callbackData = req.body;
    if (req.body.response) {
      const decoded = Buffer.from(req.body.response, 'base64').toString('utf-8');
      callbackData = JSON.parse(decoded);
    }

    // FIX 1: Robust ID Extraction (Checks root AND data object)
    const dataObj = callbackData.data || {};
    const orderId = dataObj.merchantTransactionId || dataObj.transactionId || callbackData.merchantTransactionId || callbackData.transactionId;
    // This line fixes the empty gatewayTransactionId issue:
    const gatewayId = dataObj.providerReferenceId || dataObj.transactionId || callbackData.providerReferenceId || '';
    const paymentCode = callbackData.code || dataObj.code;

    if (!orderId) {
      return res.status(400).json({ success: false, message: 'No Order ID found' });
    }

    console.log(`Processing ${orderId} | Status: ${paymentCode} | GatewayID: ${gatewayId}`);

    // FIX 2: Map Status & Clean Response
    const status = (paymentCode === 'PAYMENT_SUCCESS' || paymentCode === 'SUCCESS') ? 'paid' : 'failed';
    const cleanedResponse = cleanPhonePeResponse(callbackData); // Removes param1-20

    const orderRef = db.collection('orders').doc(orderId);
    
    // Update Main Order
    await orderRef.update({
      status: status === 'paid' ? 'confirmed' : 'cancelled',
      paymentStatus: status,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    // Upsert Payment Record
    const paymentQuery = await orderRef.collection('payment').limit(1).get();
    if (!paymentQuery.empty) {
      await paymentQuery.docs[0].ref.update({
        status: status,
        gatewayTransactionId: gatewayId, // This will now be populated correctly
        rawResponse: cleanedResponse,    // This will now be clean (no params)
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
    } else {
      await orderRef.collection('payment').add({
        status: status,
        gatewayTransactionId: gatewayId,
        rawResponse: cleanedResponse,
        timestamp: admin.firestore.FieldValue.serverTimestamp()
      });
    }

    res.json({ success: true });
  } catch (error) {
    console.error('Callback Error:', error);
    res.status(500).json({ success: false });
  }
});

app.get('/', (req, res) => res.json({ status: 'PhonePe Backend Running' }));
app.get('/health', (req, res) => res.json({ status: 'OK' }));

app.listen(PORT, '0.0.0.0', () => console.log(`Server running on port ${PORT}`));